import{createMemoryHistory,Action,parsePath}from'history';import PropTypes from'prop-types';import{createContext,useRef,useReducer,useLayoutEffect,createElement,useContext,useEffect,useMemo,useCallback,Children,isValidElement,Fragment}from'react';function k(a,b){if(!a)throw Error(b);}function l(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}let m=createContext({pending:!1,static:!1});m.displayName="Location";let n=createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});n.displayName="Route";
function q({children:a,initialEntries:b,initialIndex:c}){let d=useRef();null==d.current&&(d.current=createMemoryHistory({initialEntries:b,initialIndex:c}));let e=d.current,[g,f]=useReducer((b,a)=>a,{action:e.action,location:e.location});useLayoutEffect(()=>e.listen(f),[e]);return createElement(r,{children:a,action:g.action,location:g.location,navigator:e})}q.displayName="MemoryRouter";
q.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};
function t({to:a,replace:b,state:c}){u()?void 0:k(!1,"<Navigate> may be used only in the context of a <Router> component.");l(!useContext(m).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let d=v();useEffect(()=>{d(a,{replace:b,state:c})});return null}t.displayName="Navigate";
t.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function w(){return x()}w.displayName="Outlet";w.propTypes={};function y({element:a=createElement(w,null)}){return a}y.displayName="Route";y.propTypes={caseSensitive:PropTypes.bool,children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};
function r({children:a=null,action:b=Action.Pop,location:c,navigator:d,pending:e=!1,static:g=!1}){u()?k(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;return createElement(m.Provider,{children:a,value:{action:b,location:c,navigator:d,pending:e,static:g}})}r.displayName="Router";
r.propTypes={children:PropTypes.node,action:PropTypes.oneOf(["POP","PUSH","REPLACE"]),location:PropTypes.object.isRequired,navigator:PropTypes.shape({createHref:PropTypes.func.isRequired,push:PropTypes.func.isRequired,replace:PropTypes.func.isRequired,go:PropTypes.func.isRequired,block:PropTypes.func.isRequired}).isRequired,pending:PropTypes.bool,static:PropTypes.bool};function z({basename:a="",children:b}){b=A(b);return B(b,a)}z.displayName="Routes";z.propTypes={basename:PropTypes.string,children:PropTypes.node};
function u(){return null!=useContext(m).location}function C(){u()?void 0:k(!1,"useLocation() may be used only in the context of a <Router> component.");return useContext(m).location}
function v(){u()?void 0:k(!1,"useNavigate() may be used only in the context of a <Router> component.");let a=useContext(m),b=a.navigator,c=a.pending,{pathname:d}=useContext(n),e=useRef(!1);useEffect(()=>{e.current=!0});return useCallback((a,f={})=>{e.current?"number"===typeof a?b.go(a):(a=D(a,d),(f.replace||c?b.replace:b.push)(a,f.state)):l(!1,"You should call navigate() in a useEffect, not when your component is first rendered.")},[b,d,c])}function x(){return useContext(n).outlet}
function E(a){let {pathname:b}=useContext(n);return useMemo(()=>D(a,b),[a,b])}let F={};function G(a,b,c){b||F[a]||(F[a]=!0,l(!1,c))}
function B(a,b=""){let {route:c,pathname:d,params:e}=useContext(n);var g=c&&c.path;G(d,!c||c.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${g}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${g}"> to <Route path="${g}/*">.`);b=b?[d,b].join("/").replace(/\/\/+/g,"/"):d;
g=useRef();let f=C(),h=useMemo(()=>H(a,f,b),[f,a,b]);if(!h)return null;g.current!==f&&(g.current=f,h.forEach(({route:b,params:a},c)=>b.preload&&b.preload(a,f,c)));return h.reduceRight((a,{params:c,pathname:d,route:f})=>createElement(n.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null)}
function I(a){return a.map(b=>{let a={path:b.path||"/",caseSensitive:!0===b.caseSensitive,element:b.element||createElement(w,null),preload:b.preload};b.children&&(a.children=I(b.children));return a})}
function A(a){let b=[];Children.forEach(a,a=>{if(isValidElement(a))if(a.type===Fragment)b.push.apply(b,A(a.props.children));else{var c={path:a.props.path||"/",caseSensitive:!0===a.props.caseSensitive,element:a,preload:a.props.preload};a.props.children&&(a=A(a.props.children),a.length&&(c.children=a));b.push(c)}});return b}
function H(a,b,c=""){"string"===typeof b&&(b=parsePath(b));b=b.pathname||"/";if(c)if(c=c.replace(/^\/*/,"/").replace(/\/+$/,""),b.startsWith(c))b=b===c?"/":b.slice(c.length);else return null;a=J(a);K(a);var d=null;for(c=0;null==d&&c<a.length;++c)a:{d=b;let g=a[c][1],f="/",h={},p=[];for(let a=0;a<g.length;++a){let b=g[a];var e="/"===f?d:d.slice(f.length)||"/";e=L({path:b.path,caseSensitive:b.caseSensitive,end:a===g.length-1},e);if(!e){d=null;break a}f=[f,e.pathname].join("/").replace(/\/\/+/g,"/");
h={...h,...e.params};p.push({route:b,pathname:f,params:Object.freeze(h)})}d=p}return d}function J(a,b=[],c="",d=[],e=[]){a.forEach((a,f)=>{let g=[c,a.path].join("/").replace(/\/\/+/g,"/"),p=d.concat(a);f=e.concat(f);a.children&&J(a.children,b,g,p,f);b.push([g,p,f])});return b}function K(a){let b=a.reduce((a,[b])=>{a[b]=M(b);return a},{});N(a,(a,d)=>{let [c,,g]=a;a=b[c];let [f,,h]=d;d=b[f];return a!==d?d-a:O(g,h)})}let P=/^:\w+$/,Q=a=>"*"===a;
function M(a){a=a.split("/");let b=a.length;a.some(Q)&&(b+=-2);return a.filter(a=>"*"!==a).reduce((a,b)=>a+(P.test(b)?2:""===b?1:10),b)}function O(a,b){return a.length===b.length&&a.slice(0,-1).every((a,d)=>a===b[d])?a[a.length-1]-b[b.length-1]:0}function N(a,b){let c=a.slice(0);a.sort((a,e)=>b(a,e)||c.indexOf(a)-c.indexOf(e))}
function L(a,b){"string"===typeof a&&(a={path:a});let {path:c,caseSensitive:d=!1,end:e=!0}=a,[g,f]=R(c,d,e);b=b.match(g);if(!b)return null;a=b[1];let h=b.slice(2);b=f.reduce((a,b,c)=>{c=h[c];try{var d=decodeURIComponent(c.replace(/\+/g," "))}catch(S){l(!1,`The value for the URL param "${b}" will not be decoded because`+` the string "${c}" is a malformed URL segment. This is probably`+` due to a bad percent encoding (${S}).`),d=c}a[b]=d;return a},{});return{path:c,pathname:a,params:b}}
function R(a,b,c){let d=[],e="^("+a.replace(/^\/*/,"/").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):c&&(e+="\\/?");c&&(e+="$");return[new RegExp(e,b?void 0:"i"),d]}function D(a,b="/"){let {pathname:c,search:d="",hash:e=""}="string"===typeof a?parsePath(a):a;return{pathname:c?T(c,c.startsWith("/")?"/":b):b,search:d,hash:e}}
function T(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}
function generatePath(a,b={}){return a.replace(/:(\w+)/g,(a,d)=>{null==b[d]?k(!1,`Missing ":${d}" param`):void 0;return b[d]}).replace(/\/*\*$/,()=>null==b["*"]?"":b["*"].replace(/^\/*/,"/"))};
function useBlocker(a,b=!0){u()?void 0:k(!1,"useBlocker() may be used only in the context of a <Router> component.");let c=useContext(m).navigator;useEffect(()=>{if(b){var d=c.block(b=>{a({...b,retry(){d();b.retry()}})});return d}},[c,a,b])};function useHref(a){u()?void 0:k(!1,"useHref() may be used only in the context of a <Router> component.");let b=useContext(m).navigator;a=E(a);return b.createHref(a)};function useLocationPending(){return useContext(m).pending};
function useMatch(a){u()?void 0:k(!1,"useMatch() may be used only in the context of a <Router> component.");let b=C();return L(a,b.pathname)};function useParams(){return useContext(n).params};function useRoutes(a,b=""){u()?void 0:k(!1,"useRoutes() may be used only in the context of a <Router> component.");let c=useMemo(()=>I(a),[a]);return B(c,b)};export{q as MemoryRouter,t as Navigate,w as Outlet,y as Route,r as Router,z as Routes,I as createRoutesFromArray,A as createRoutesFromChildren,generatePath,L as matchPath,H as matchRoutes,D as resolveLocation,useBlocker,useHref,u as useInRouterContext,C as useLocation,useLocationPending,useMatch,v as useNavigate,x as useOutlet,useParams,E as useResolvedLocation,useRoutes}
//# sourceMappingURL=react-router.development.js.map
