import * as React from 'react';
import PropTypes from 'prop-types';
import { Action, Path, State, LocationPieces, Location, Blocker, To, History, InitialEntry } from 'history';
/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level <Router> API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */
export declare type Navigator = Omit<History, 'action' | 'location' | 'back' | 'forward' | 'listen'>;
/**
 * A <Router> that stores all entries in memory.
 */
export declare function MemoryRouter({ children, initialEntries, initialIndex }: MemoryRouterProps): React.ReactElement;
export declare namespace MemoryRouter {
    var displayName: string;
    var propTypes: {
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        timeout: PropTypes.Requireable<number>;
        initialEntries: PropTypes.Requireable<(string | PropTypes.InferProps<{
            pathname: PropTypes.Requireable<string>;
            search: PropTypes.Requireable<string>;
            hash: PropTypes.Requireable<string>;
            state: PropTypes.Requireable<object>;
            key: PropTypes.Requireable<string>;
        }> | null | undefined)[]>;
        initialIndex: PropTypes.Requireable<number>;
    };
}
export interface MemoryRouterProps {
    children?: React.ReactNode;
    initialEntries?: InitialEntry[];
    initialIndex?: number;
}
/**
 * Navigate programmatically using a component.
 */
export declare function Navigate({ to, replace, state }: NavigateProps): null;
export declare namespace Navigate {
    var displayName: string;
    var propTypes: {
        to: PropTypes.Validator<string | PropTypes.InferProps<{
            pathname: PropTypes.Requireable<string>;
            search: PropTypes.Requireable<string>;
            hash: PropTypes.Requireable<string>;
        }>>;
        replace: PropTypes.Requireable<boolean>;
        state: PropTypes.Requireable<object>;
    };
}
export interface NavigateProps {
    to: To;
    replace?: boolean;
    state?: State;
}
/**
 * Renders the child route's element, if there is one.
 */
export declare function Outlet(): React.ReactElement | null;
export declare namespace Outlet {
    var displayName: string;
    var propTypes: {};
}
export interface OutletProps {
}
/**
 * Used in a route config to render an element.
 */
export declare function Route({ element }: RouteProps): React.ReactElement | null;
export declare namespace Route {
    var displayName: string;
    var propTypes: {
        caseSensitive: PropTypes.Requireable<boolean>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        element: PropTypes.Requireable<PropTypes.ReactElementLike>;
        path: PropTypes.Requireable<string>;
    };
}
export interface RouteProps {
    caseSensitive?: boolean;
    children?: React.ReactNode;
    element?: React.ReactElement | null;
    path?: string;
}
/**
 * The low-level root context provider in a React Router app. You usually won't
 * render a <Router> directly. Instead, you'll render a router that is more
 * specific to your environment such as a <BrowserRouter> in web browsers or a
 * <StaticRouter> for server rendering.
 */
export declare function Router({ children, action, location, navigator, pending, static: staticProp }: RouterProps): React.ReactElement;
export declare namespace Router {
    var displayName: string;
    var propTypes: {
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        action: PropTypes.Requireable<string>;
        location: PropTypes.Validator<object>;
        navigator: PropTypes.Validator<PropTypes.InferProps<{
            createHref: PropTypes.Validator<(...args: any[]) => any>;
            push: PropTypes.Validator<(...args: any[]) => any>;
            replace: PropTypes.Validator<(...args: any[]) => any>;
            go: PropTypes.Validator<(...args: any[]) => any>;
            block: PropTypes.Validator<(...args: any[]) => any>;
        }>>;
        pending: PropTypes.Requireable<boolean>;
        static: PropTypes.Requireable<boolean>;
    };
}
export interface RouterProps {
    children?: React.ReactNode;
    action?: Action;
    location: Location;
    navigator: Navigator;
    pending?: boolean;
    static?: boolean;
}
/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 */
export declare function Routes({ basename, children }: RoutesProps): React.ReactElement | null;
export declare namespace Routes {
    var displayName: string;
    var propTypes: {
        basename: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
    };
}
export interface RoutesProps {
    basename?: string;
    children?: React.ReactNode;
}
/**
 * Blocks all navigation attempts. This is useful for preventing the page from
 * changing until some condition is met, like saving form data.
 */
export declare function useBlocker(blocker: Blocker, when?: boolean): void;
/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 */
export declare function useHref(to: To): string;
/**
 * Returns true if this component is a descendant of a <Router>.
 */
export declare function useInRouterContext(): boolean;
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * NOTE: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may be
 * able to provide something higher-level to better suit your needs.
 */
export declare function useLocation(): Location;
/**
 * Returns true if the router is pending a location update.
 */
export declare function useLocationPending(): boolean;
/**
 * Returns true if the URL for the given "to" value matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 */
export declare function useMatch(path: PathPattern): PathMatch | null;
declare type PathPattern = string | {
    path: string;
    caseSensitive?: boolean;
    end?: boolean;
};
/**
 * The interface for the navigate() function returned from useNavigate().
 */
export interface NavigateFunction {
    (delta: number): void;
    (to: To, options?: {
        replace?: boolean;
        state?: State;
    }): void;
}
/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 */
export declare function useNavigate(): NavigateFunction;
/**
 * Returns the outlet element at this level of the route hierarchy. Used to
 * render child routes.
 */
export declare function useOutlet(): React.ReactElement | null;
/**
 * Returns a hash of the dynamic params that were matched in the route path.
 * This is useful for using ids embedded in the URL to fetch data, but we
 * eventually want to provide something at a higher level for this.
 */
export declare function useParams(): Params;
/**
 * Returns a fully-resolved location object relative to the current location.
 */
export declare function useResolvedLocation(to: To): ResolvedLocation;
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 */
export declare function useRoutes(partialRoutes: PartialRouteObject[], basename?: string): React.ReactElement | null;
/**
 * Creates a routes config object from an array of {@link PartialRouteObject}
 * objects.
 */
export declare function createRoutesFromArray(array: PartialRouteObject[]): RouteObject[];
/**
 * Creates a routes config object from a React "children" object, which is
 * usually either a {@link Route | `<Route>`} element (with its children) or an
 * array of them.
 */
export declare function createRoutesFromChildren(children: React.ReactNode): RouteObject[];
/**
 * A function that will be called when the router is about to render the
 * associated route. This function usually kicks off a fetch or similar
 * operation that primes a local data cache for retrieval while rendering later.
 */
declare type RoutePreloadFunction = (params: Params, location: Location, index: number) => void;
/**
 * A "partial route" object is usually supplied by the user and may omit certain
 * properties of a real route object such as `path` and `element`, which have
 * reasonable defaults.
 */
export interface PartialRouteObject {
    path?: string;
    caseSensitive?: boolean;
    element?: React.ReactNode;
    preload?: RoutePreloadFunction;
    children?: PartialRouteObject[];
}
/**
 * A route object represents a logical route, with (optionally) its child routes
 * organized in a tree-like structure.
 */
export interface RouteObject {
    path: string;
    caseSensitive: boolean;
    element: React.ReactNode;
    preload?: RoutePreloadFunction;
    children?: RouteObject[];
}
/**
 * Creates a path with params interpolated.
 */
export declare function generatePath(pathname: string, params?: Params): string;
/**
 * The parameters that were parsed from the URL path.
 */
export declare type Params = Record<string, string>;
/**
 * Matches the given routes to a location and returns the match data.
 */
export declare function matchRoutes(routes: RouteObject[], location: Path | LocationPieces, basename?: string): RouteMatch[] | null;
export interface RouteMatch {
    route: RouteObject;
    pathname: string;
    params: Params;
}
/**
 * Performs pattern matching on a URL pathname and returns information about the
 * match.
 */
export declare function matchPath(pattern: PathPattern, pathname: string): PathMatch | null;
export interface PathMatch {
    path: string;
    pathname: string;
    params: Params;
}
/**
 * Returns a fully resolved location object relative to the given pathname.
 */
export declare function resolveLocation(to: To, fromPathname?: string): ResolvedLocation;
export declare type ResolvedLocation = Omit<Location, 'state' | 'key'>;
export {};
